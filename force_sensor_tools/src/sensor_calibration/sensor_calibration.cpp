#include "sensor_calibration.h"
#include "tinyxml2.h"

using namespace tinyxml2;

RETURN_CODE SensorCalibration::init()
{
    RETURN_CODE ret;
    add_position_srv_ = nh_.advertiseService("add_position", &SensorCalibration::addPositionCallback, this);
    clear_position_srv_ = nh_.advertiseService("clear_position", &SensorCalibration::clearPositionCallback, this);
    calibration_srv_ = nh_.advertiseService("calibration", &SensorCalibration::calibrationCallback, this);
    get_float_value_cli_ = nh_.serviceClient<force_sensor_tools::GetFloatValue>("get_float_value");
    joint_state_sub_ = nh_.subscribe("ur_driver/joint_states", 1000, &SensorCalibration::getJointStateCallback, this);
    jointState_.resize(JOINT_NUM);
    ret = engine_.init();
    return ret;
}

RETURN_CODE SensorCalibration::start()
{
    ros::spin();
    return SUCCESS;
}

bool SensorCalibration::addPositionCallback(std_srvs::SetBool::Request &request,
                                            std_srvs::SetBool::Response &response)
{
    CalibrationData cd;
    // 获取传感器参数
    force_sensor_tools::GetFloatValue srv;
    if (get_float_value_cli_.call(srv)) {
        ROS_INFO("get force sensor value:\nforce_x: %f, force_y: %f, force_z: %f,\nmoment_x: %f, moment_y: %f, moment_z: %f",
                  srv.response.force_x, srv.response.force_y, srv.response.force_z,
                  srv.response.moment_x, srv.response.force_y, srv.response.force_z);
        cd.sensorValue.forceX = srv.response.force_x;
        cd.sensorValue.forceY = srv.response.force_y;
        cd.sensorValue.forceZ = srv.response.force_z;
        cd.sensorValue.momentX = srv.response.moment_x;
        cd.sensorValue.momentY = srv.response.moment_y;
        cd.sensorValue.momentZ = srv.response.moment_z;
    } else {
        ROS_ERROR("Failed to call service get_float_value");
        response.success = true;
        response.message = "Failed to call service get_float_value";
        return false;
    }

    // 获取手臂姿态
    {
        std::unique_lock<std::mutex> lockGuard(jointStateMtx_);
        for (int i = 0; i < JOINT_NUM; i++) {
            cd.jointState[i] = jointState_[i];
        }
        ROS_INFO("get joint state: %f | %f | %f | %f| %f |%f",
                 jointState_[0], jointState_[1], jointState_[2], jointState_[3], jointState_[4], jointState_[5]);
    }

    // 存储数据到算法引擎
    engine_.addPosition(cd);

    response.success = true;
    response.message = "success";
    return true;
}

bool SensorCalibration::clearPositionCallback(std_srvs::SetBool::Request &request,
                                              std_srvs::SetBool::Response &response)
{
    engine_.clearPosition();
    response.success = true;
    response.message = "success";
    return true;
}

bool SensorCalibration::calibrationCallback(std_srvs::SetBool::Request &request,
                                            std_srvs::SetBool::Response &response)
{
    RETURN_CODE ret;
    CalibrationResult result;
    ret = engine_.caculate(result);
    if (ret != SUCCESS) {
        response.success = false;
        response.message = "error";
        return false;
    }

    // 将标定结果生成XML存到本地
    generateXMLFile(result);

    response.success = true;
    response.message = "success";
    return true;
}

RETURN_CODE SensorCalibration::generateXMLFile(CalibrationResult& result)
{
    XMLDocument Doc;
	XMLComment* pComment1 = Doc.NewComment(" The file is generated by force sensor tools. ");
	Doc.LinkEndChild(pComment1);
	XMLComment* pComment2 = Doc.NewComment(" If you have any questions, please contact Wang Tao. ");
	Doc.LinkEndChild(pComment2);
	XMLComment* pComment3 = Doc.NewComment(" Controls whether the driver turns on calibration. ");
	Doc.LinkEndChild(pComment3);

    XMLElement* pElementSwitch = Doc.NewElement("UseCalibration");
    XMLText* pText1 = Doc.NewText("false");
    pElementSwitch->LinkEndChild(pText1);
	Doc.LinkEndChild(pElementSwitch);

	XMLComment* pComment4 = Doc.NewComment(" Sensor parameters used to correct errors. ");
	Doc.LinkEndChild(pComment4);
	XMLElement* pElementParameter = Doc.NewElement("Parameter");
	Doc.LinkEndChild(pElementParameter);

    XMLElement* pElementCentroidX = Doc.NewElement("centroidX");
    XMLText* pText2 = Doc.NewText(std::to_string(result.centroidX).c_str());
    pElementCentroidX->LinkEndChild(pText2);
    pElementParameter->LinkEndChild(pElementCentroidX);

    XMLElement* pElementCentroidY = Doc.NewElement("centroidY");
    XMLText* pText3 = Doc.NewText(std::to_string(result.centroidY).c_str());
    pElementCentroidY->LinkEndChild(pText3);
    pElementParameter->LinkEndChild(pElementCentroidY);

    XMLElement* pElementCentroidZ = Doc.NewElement("centroidZ");
    XMLText* pText4 = Doc.NewText(std::to_string(result.centroidY).c_str());
    pElementCentroidZ->LinkEndChild(pText4);
    pElementParameter->LinkEndChild(pElementCentroidZ);

    XMLElement* pElementGcos = Doc.NewElement("Gcos");
    XMLText* pText5 = Doc.NewText(std::to_string(result.Gcos).c_str());
    pElementGcos->LinkEndChild(pText5);
    pElementParameter->LinkEndChild(pElementGcos);

    XMLElement* pElementGsin = Doc.NewElement("Gsin");
    XMLText* pText6 = Doc.NewText(std::to_string(result.Gsin).c_str());
    pElementGsin->LinkEndChild(pText6);
    pElementParameter->LinkEndChild(pElementGsin);

    XMLElement* pElementG = Doc.NewElement("G");
    XMLText* pText7 = Doc.NewText(std::to_string(result.G).c_str());
    pElementG->LinkEndChild(pText7);
    pElementParameter->LinkEndChild(pElementG);

    XMLElement* pElementForceX0 = Doc.NewElement("forceX0");
    XMLText* pText8 = Doc.NewText(std::to_string(result.forceX0).c_str());
    pElementForceX0->LinkEndChild(pText8);
    pElementParameter->LinkEndChild(pElementForceX0);

    XMLElement* pElementForceY0 = Doc.NewElement("forceY0");
    XMLText* pText9 = Doc.NewText(std::to_string(result.forceY0).c_str());
    pElementForceY0->LinkEndChild(pText9);
    pElementParameter->LinkEndChild(pElementForceY0);

    XMLElement* pElementForceZ0 = Doc.NewElement("forceZ0");
    XMLText* pText10 = Doc.NewText(std::to_string(result.forceZ0).c_str());
    pElementForceZ0->LinkEndChild(pText10);
    pElementParameter->LinkEndChild(pElementForceZ0);

    XMLElement* pElementMomentX0 = Doc.NewElement("momentX0");
    XMLText* pText11 = Doc.NewText(std::to_string(result.momentX0).c_str());
    pElementMomentX0->LinkEndChild(pText11);
    pElementParameter->LinkEndChild(pElementMomentX0);

    XMLElement* pElementMomentY0 = Doc.NewElement("momentY0");
    XMLText* pText12 = Doc.NewText(std::to_string(result.momentY0).c_str());
    pElementMomentY0->LinkEndChild(pText12);
    pElementParameter->LinkEndChild(pElementMomentY0);

    XMLElement* pElementMomentZ0 = Doc.NewElement("momentZ0");
    XMLText* pText13 = Doc.NewText(std::to_string(result.momentZ0).c_str());
    pElementMomentZ0->LinkEndChild(pText13);
    pElementParameter->LinkEndChild(pElementMomentZ0);

	Doc.SaveFile("calibration_config.xml");
    return SUCCESS;
}

void SensorCalibration::getJointStateCallback(const sensor_msgs::JointState& msg)
{
    std::unique_lock<std::mutex> lockGuard(jointStateMtx_);
    if(msg.position.size() == JOINT_NUM) {
        for (int i = 0; i < JOINT_NUM; ++i) {
            jointState_[i] = msg.position[i];
        }
    } else {
        ROS_ERROR("Failed to get JointState");
    }
}
